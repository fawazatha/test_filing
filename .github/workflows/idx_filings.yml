name: IDX Filings

on:
  schedule:
    - cron: "0 */2 * * *"
  workflow_dispatch:
    inputs:
      mode:
        description: "Run mode"
        type: choice
        required: true
        default: lookback
        options: [single_day, range, lookback]
      time:
        description: |
          For single_day: YYYYMMDD|HH:MM|HH:MM
          For range: YYYYMMDD..YYYYMMDD
          For lookback: leave empty
        required: false
      window_minutes:
        description: "Lookback minutes (lookback mode only)"
        required: false
        default: "120"
      # ===== NEW: company assets controls =====
      refresh_company_assets:
        description: "Refresh company map + latest prices before run?"
        type: boolean
        default: true
      prices_lookback_days:
        description: "Lookback days for latest prices"
        required: false
        default: "14"
      no_price_fallback:
        description: "Disable per-symbol fallback (not recommended)"
        type: boolean
        default: false
      # ===== Existing flags =====
      upload_to_supabase:
        description: "Upload filings to Supabase? (needs secrets)"
        type: boolean
        default: false
      send_alerts:
        description: "Send SES email alerts?"
        type: boolean
        default: false
      generate_articles:
        description: "Generate articles.jsonl from filings?"
        type: boolean
        default: true
      upload_news:
        description: "Upload articles to Supabase idx_news?"
        type: boolean
        default: true
      news_table:
        description: "Supabase news table"
        required: false
        default: "idx_news"
      use_llm:
        description: "Use LLM if API key present"
        type: boolean
        default: true
      verbose:
        description: "Verbose logs?"
        type: boolean
        default: true

env:
  PYTHONPATH: src
  TZ: Asia/Jakarta
  OVERLAP_MINUTES: "1"

concurrency:
  group: idx-filings-manual
  cancel-in-progress: true

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install -U pip
          pip install -r requirements.txt

      - name: Pre-clean
        run: |
          rm -rf downloads/idx-format downloads/non-idx-format || true
          rm -rf data/*.json data/*.jsonl alerts/*.json alerts_inserted alerts_not_inserted artifacts/*.zip || true
          mkdir -p downloads/idx-format downloads/non-idx-format data alerts artifacts

      - name: Compute run timestamp (WIB)
        id: ts
        run: echo "stamp=$(date +'%Y%m%d-%H%M%S')" >> "$GITHUB_OUTPUT"

      - name: Run orchestrator
        env:
          # ===== App secrets =====
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}

          # (Optional) HTTP proxy only for IDX fetch/downloader
          HTTP_PROXY:  ${{ secrets.PROXY }}
          HTTPS_PROXY: ${{ secrets.PROXY }}
          NO_PROXY: "localhost,127.0.0.1,supabase.co,.supabase.co,amazonaws.com,.amazonaws.com"

          # ===== AWS / SES (for emailing alerts) =====
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION:            ${{ secrets.AWS_REGION }}
          SES_FROM_EMAIL:        ${{ secrets.SES_FROM_EMAIL }}

          ALERT_TO_EMAIL_INSERTED:     ${{ secrets.ALERT_TO_EMAIL }}
          ALERT_TO_EMAIL_NOT_INSERTED: ${{ secrets.ALERT_TO_EMAIL }}

          # ===== (Optional) LLM keys =====
          GROQ_API_KEY:   ${{ secrets.GROQ_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        shell: bash
        run: |
          set -euo pipefail

          ARGS=( "--zip-artifacts" "--artifact-prefix" "filings" )

          # Verbose?
          if [[ "${{ inputs.verbose }}" == "true" || "${{ github.event_name }}" == "schedule" ]]; then
            ARGS+=("-v")
          fi

          MODE="${{ inputs.mode }}"
          TIME_RAW="${{ inputs.time }}"  # may be empty

          # ========== Sanitize 'time' input ==========
          TIME="$(echo "${TIME_RAW:-}" | tr -d '[:space:]')"
          digits_only() { printf '%s' "$1" | tr -cd '0-9'; }

          # ===== Default behavior on schedule =====
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            # default scheduled run: lookback with slight overlap + upload filings
            WIN=$(( 120 + ${OVERLAP_MINUTES:-1} ))
            ARGS+=( "--window-minutes" "$WIN" "--upload" "--table" "idx_filings" )
            # NEW: always refresh company assets on schedule
            ARGS+=( "--refresh-company-assets" "--prices-lookback-days" "${{ inputs.prices_lookback_days }}" )
            if [[ "${{ inputs.no_price_fallback }}" == "true" ]]; then
              ARGS+=( "--no-price-fallback" )
            fi
          else
            # ===== Manual workflow_dispatch modes =====
            case "$MODE" in
              single_day)
                # Expect TIME: YYYYMMDD|HH:MM|HH:MM
                if [[ -z "${TIME:-}" || "${TIME}" != *"|"* ]]; then
                  echo "::error::For mode=single_day, 'time' must be 'YYYYMMDD|HH:MM|HH:MM'"; exit 1;
                fi
                IFS='|' read -r DATE SD ED <<< "$TIME"

                DATE="$(digits_only "${DATE}")"
                SD="${SD//[^0-9:]/}"
                ED="${ED//[^0-9:]/}"

                [[ ${#DATE} -eq 8 ]] || { echo "::error::DATE must be YYYYMMDD"; exit 1; }
                [[ "$SD" =~ ^[0-2][0-9]:[0-5][0-9]$ ]] || { echo "::error::start time must be HH:MM"; exit 1; }
                [[ "$ED" =~ ^[0-2][0-9]:[0-5][0-9]$ ]] || { echo "::error::end time must be HH:MM"; exit 1; }

                ARGS+=( "--date" "$DATE" "--start-hhmm" "$SD" "--end-hhmm" "$ED" )
                ;;
              range)
                # Expect TIME: YYYYMMDD..YYYYMMDD
                if [[ -z "${TIME:-}" || "${TIME}" != *".."* ]]; then
                  echo "::error::For mode=range, 'time' must be 'YYYYMMDD..YYYYMMDD'"; exit 1;
                fi
                IFS='..' read -r FROMD TOD <<< "$TIME"

                FROMD="$(digits_only "${FROMD}")"
                TOD="$(digits_only "${TOD}")"

                [[ ${#FROMD} -eq 8 && ${#TOD} -eq 8 ]] || { echo "::error::from/to must be YYYYMMDD"; exit 1; }

                ARGS+=( "--from-date" "$FROMD" "--to-date" "$TOD" )
                ;;
              lookback|*)
                WIN="${{ inputs.window_minutes }}"
                ARGS+=( "--window-minutes" "$WIN" )
                ;;
            esac
            if [[ "${{ inputs.upload_to_supabase }}" == "true" ]]; then
              ARGS+=( "--upload" "--table" "idx_filings" )
            fi

            # NEW: refresh company assets when requested (default true)
            if [[ "${{ inputs.refresh_company_assets }}" == "true" ]]; then
              ARGS+=( "--refresh-company-assets" "--prices-lookback-days" "${{ inputs.prices_lookback_days }}" )
              if [[ "${{ inputs.no_price_fallback }}" == "true" ]]; then
                ARGS+=( "--no-price-fallback" )
              fi
            fi
          fi

          # ==== Articles generation & upload news ====
          if [[ "${{ inputs.generate_articles }}" == "true" || "${{ github.event_name }}" == "schedule" ]]; then
            ARGS+=( "--generate-articles" "--articles-out" "data/articles.jsonl" )
          fi
          if [[ "${{ inputs.upload_news }}" == "true" || "${{ github.event_name }}" == "schedule" ]]; then
            ARGS+=( "--upload-news" "--news-table" "${{ inputs.news_table }}" "--prefer-symbol" )
          fi

          # ==== LLM toggling (auto-enable only if key present) ====
          if [[ "${{ inputs.use_llm }}" == "true" ]]; then
            if [[ -n "${GROQ_API_KEY:-}" || -n "${OPENAI_API_KEY:-}" || -n "${GEMINI_API_KEY:-}" ]]; then
              ARGS+=( "--use-llm" )
            else
              echo "::notice::USE_LLM=true but no API key found; continuing without LLM."
            fi
          fi

          # ==== Email alerts toggling ====
          if [[ "${{ github.event_name }}" == "schedule" || "${{ inputs.send_alerts }}" == "true" ]]; then
            ARGS+=( "--email-alerts" )
          else
            echo "::notice::Email alerts disabled for this run."
          fi

          echo "python -m pipeline.orchestrator ${ARGS[*]}"
          python -m pipeline.orchestrator "${ARGS[@]}"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: filings-manual-${{ steps.ts.outputs.stamp }}-run${{ github.run_number }}
          path: |
            artifacts/*.zip
            data/*.json
            data/*.jsonl
            data/company/*.json
            alerts/*.json
            alerts_inserted/*.json
            alerts_not_inserted/*.json
          if-no-files-found: warn
          retention-days: 14
          compression-level: 6
